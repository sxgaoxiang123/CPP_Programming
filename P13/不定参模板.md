# 不定参模板

在定义模板时类似函数可以传递不定参类型，从而在其下的模板函数或模板类中使用这些不定参类型，更灵活的实现某些需求

```cpp
#include <iostream>
using namespace std;

//定义只处理一个参数的模板函数，用于递归终止条件
template <class T>
void print(T a) {
    cout << a << endl;
}

//传递不定参的模板函数
template <class T, class ...ARGS>
void print(T a, ARGS... args) {
    cout << a << endl;
    print(args...); //递归调用
}

//模板类
template <class T, class ...ARGS>
class N_ARGS {
public:
    typedef T type;
    typedef N_ARGS <ARGS...> rest; //少传一个参数T，类似递归
};

//部分特化版本，只有一个参数的情况，用于递归终止条件
template <class T>
class N_ARGS<T> {
public:
    typedef T type;
    typedef T last; //用于表征是最后一个传入的类型参数
};

template <class T, class ...ARGS> class Test; //普通类模板

template <class T, class ...ARGS> //Test类的偏特化模板
class Test<T(ARGS...)> {
public:
    T operator()(typename N_ARGS<ARGS...>::type a,\
                 typename N_ARGS<ARGS...>::rest::last b) {
        return a + b;
    }
};

int main(int argc, char *argv[]) {
    print(123);
    print(12.3, "aaa");
    print("asdhsiu", 3, 333, 222.222);

    N_ARGS<int, double, string>::type a;
    N_ARGS<int, double, string>::rest::type b;
    N_ARGS<int, double, string>::rest::rest::type c;
    N_ARGS<int, double, string>::rest::rest::last d; //指明是最后一个

    cout << typeid(a).name() << endl;
    cout << typeid(b).name() << endl;
    cout << typeid(c).name() << endl;

    cout << "=========================" << endl;

    Test<int(int, int)> t1; //仿函数形式的模板
    Test<double(double, int)> t2;

    cout << t1(1.1, 2.2) << endl;
    cout << t2(1.1, 2.2) << endl;

    return 0;
}
```

如上代码：

1. 不定参模板函数和类的实现类似于递归

   1. template <class T, class ...ARGS>，传递两个参数T和不定参ARGS

   2. 在模板函数或模板类中递归调用，只传递不定参ARGS，而不传递T，这样就实现了向后遍历不定参中的类型

   3. 递归遍历需要终止条件，可以定义只有一个参数的模板函数或类（部分特化）

      template <class T>

2. Test模板类可以通过部分特化实现仿函数形式的传参，注意在定义部分特化模板之前要先定义通用模板

